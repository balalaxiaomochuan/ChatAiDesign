# 程序员常见面试题

## 一、Java基础

### 1.1 Java语言特性

**Q: Java的特点是什么？**
- 面向对象：封装、继承、多态
- 平台无关性：一次编写，到处运行（JVM）
- 自动内存管理：垃圾回收机制
- 多线程支持：内置线程支持
- 安全性：字节码验证、安全管理器

**Q: JDK、JRE、JVM的区别？**
- **JDK（Java Development Kit）**：Java开发工具包，包含JRE和开发工具（编译器javac、调试器等）
- **JRE（Java Runtime Environment）**：Java运行环境，包含JVM和核心类库
- **JVM（Java Virtual Machine）**：Java虚拟机，执行字节码文件

**Q: == 和 equals() 的区别？**
- `==`：比较基本数据类型时比较值，比较引用类型时比较内存地址
- `equals()`：Object类的方法，默认比较地址，String等类重写了equals()比较内容
- 重写equals()时必须重写hashCode()

### 1.2 面向对象

**Q: 面向对象的三大特性？**
- **封装**：隐藏对象内部实现细节，通过访问修饰符控制访问
- **继承**：子类继承父类的属性和方法，实现代码复用
- **多态**：同一接口的不同实现，包括编译时多态（重载）和运行时多态（重写）

**Q: 抽象类和接口的区别？**
| 特性 | 抽象类 | 接口 |
|------|--------|------|
| 关键字 | abstract class | interface |
| 成员变量 | 可以有普通变量 | 只能是常量（public static final） |
| 方法 | 可以有抽象方法和普通方法 | Java 8前只能有抽象方法 |
| 继承 | 单继承 | 多实现 |
| 构造方法 | 可以有 | 不能有 |
| 使用场景 | 代码复用，模板方法模式 | 定义规范，多态 |

**Q: final关键字的作用？**
- 修饰类：类不能被继承
- 修饰方法：方法不能被重写
- 修饰变量：变量只能赋值一次（基本类型值不变，引用类型引用不变）

### 1.3 集合框架

**Q: List、Set、Map的区别？**
- **List**：有序、可重复，通过索引访问
  - ArrayList：数组实现，随机访问快，插入删除慢
  - LinkedList：链表实现，插入删除快，随机访问慢
  - Vector：线程安全但性能差，已不推荐使用

- **Set**：无序、不可重复
  - HashSet：哈希表实现，无序
  - LinkedHashSet：保持插入顺序
  - TreeSet：红黑树实现，有序

- **Map**：键值对，键唯一
  - HashMap：哈希表，线程不安全
  - Hashtable：线程安全但性能差
  - ConcurrentHashMap：线程安全的HashMap
  - TreeMap：红黑树，有序

**Q: HashMap的实现原理？**
- 基于哈希表（数组+链表+红黑树）
- 初始容量16，负载因子0.75
- 当链表长度>=8且数组长度>=64时，链表转红黑树
- 当红黑树节点<=6时，转回链表
- 扩容时容量翻倍，重新计算hash

**Q: ConcurrentHashMap的实现原理？**
- JDK 1.7：分段锁（Segment）
- JDK 1.8：CAS + synchronized锁头节点
- 支持高并发读写

### 1.4 异常处理

**Q: Error和Exception的区别？**
- **Error**：系统错误，程序无法处理（OutOfMemoryError、StackOverflowError）
- **Exception**：程序异常，可以捕获处理
  - **RuntimeException**：运行时异常，非检查异常（NullPointerException、IndexOutOfBoundsException）
  - **Checked Exception**：检查异常，必须处理（IOException、SQLException）

**Q: throw和throws的区别？**
- `throw`：在方法内部抛出异常对象
- `throws`：在方法声明中声明可能抛出的异常类型

## 二、多线程

### 2.1 线程基础

**Q: 创建线程的方式？**
1. 继承Thread类
2. 实现Runnable接口（推荐）
3. 实现Callable接口（有返回值）
4. 线程池创建

**Q: 线程的状态？**
- NEW：新建
- RUNNABLE：可运行
- BLOCKED：阻塞（等待锁）
- WAITING：等待（wait()）
- TIMED_WAITING：超时等待（sleep()）
- TERMINATED：终止

**Q: sleep()和wait()的区别？**
| 特性 | sleep() | wait() |
|------|---------|-------|
| 所属类 | Thread | Object |
| 释放锁 | 否 | 是 |
| 使用场景 | 暂停执行 | 线程通信 |
| 唤醒方式 | 时间到自动唤醒 | notify()/notifyAll() |

### 2.2 线程同步

**Q: synchronized的实现原理？**
- 基于JVM的monitor机制
- 修饰代码块：使用monitorenter/monitorexit指令
- 修饰方法：方法标志位ACC_SYNCHRONIZED
- 锁升级：无锁 → 偏向锁 → 轻量级锁 → 重量级锁

**Q: volatile关键字的作用？**
- 保证可见性：修改立即刷新到主内存
- 禁止指令重排序：内存屏障
- 不保证原子性：不能替代synchronized

**Q: CAS原理？**
- Compare And Swap：比较并交换
- 原子操作，无锁实现
- ABA问题：版本号解决
- 自旋消耗CPU

**Q: ReentrantLock和synchronized的区别？**
| 特性 | synchronized | ReentrantLock |
|------|--------------|---------------|
| 锁类型 | JVM内置锁 | API层面的锁 |
| 自动释放 | 是 | 需要手动unlock() |
| 可中断 | 否 | 是（lockInterruptibly()） |
| 公平锁 | 非公平 | 可公平可非公平 |
| 条件变量 | 一个 | 多个（Condition） |

### 2.3 线程池

**Q: 线程池的核心参数？**
- corePoolSize：核心线程数
- maximumPoolSize：最大线程数
- keepAliveTime：空闲线程存活时间
- workQueue：任务队列
- threadFactory：线程工厂
- handler：拒绝策略

**Q: 线程池的拒绝策略？**
- AbortPolicy：抛异常（默认）
- CallerRunsPolicy：调用者执行
- DiscardPolicy：丢弃任务
- DiscardOldestPolicy：丢弃最老任务

**Q: 线程池的执行流程？**
1. 核心线程未满 → 创建核心线程执行
2. 核心线程已满 → 任务入队
3. 队列已满 → 创建非核心线程
4. 线程数达最大值 → 执行拒绝策略

## 三、JVM

### 3.1 内存模型

**Q: JVM内存区域划分？**
- **程序计数器**：当前线程执行的字节码行号
- **Java虚拟机栈**：局部变量表、操作数栈、方法出口
- **本地方法栈**：Native方法
- **堆**：对象实例（新生代、老年代）
- **方法区**：类信息、常量、静态变量（JDK 8后改为元空间）

**Q: 堆内存的划分？**
- **新生代**（1/3）
  - Eden区（8/10）
  - Survivor0（1/10）
  - Survivor1（1/10）
- **老年代**（2/3）

**Q: 对象的内存分配过程？**
1. 对象优先在Eden分配
2. 大对象直接进入老年代
3. 长期存活对象进入老年代（年龄>=15）
4. 动态年龄判断

### 3.2 垃圾回收

**Q: 如何判断对象是否可回收？**
- **引用计数法**：循环引用问题
- **可达性分析**：GC Roots（栈、方法区、本地方法栈、常量引用）

**Q: 垃圾回收算法？**
- **标记-清除**：效率低，产生碎片
- **标记-复制**：效率高，浪费空间（新生代）
- **标记-整理**：效率低，无碎片（老年代）
- **分代收集**：新生代用复制，老年代用标记-整理

**Q: 常见的垃圾收集器？**
- **Serial**：单线程，适合小应用
- **ParNew**：多线程版Serial
- **Parallel Scavenge**：吞吐量优先
- **CMS**：低延迟，标记-清除
- **G1**：区域化，可预测停顿时间
- **ZGC**：低延迟，大堆内存

**Q: 内存泄漏和内存溢出？**
- **内存泄漏**：对象无法回收，内存逐渐耗尽
- **内存溢出**：内存不足，无法分配新对象（OutOfMemoryError）

## 四、Spring框架

### 4.1 Spring Core

**Q: Spring的IoC和DI？**
- **IoC（控制反转）**：对象创建控制权交给Spring容器
- **DI（依赖注入）**：通过构造器、setter、字段注入依赖

**Q: Bean的作用域？**
- singleton：单例（默认）
- prototype：每次创建新实例
- request：HTTP请求级别
- session：HTTP会话级别
- globalSession：全局会话

**Q: Spring Bean的生命周期？**
1. 实例化Bean
2. 设置属性值
3. 调用BeanNameAware
4. 调用BeanFactoryAware
5. 调用ApplicationContextAware
6. 调用BeanPostProcessor的postProcessBeforeInitialization
7. 调用InitializingBean的afterPropertiesSet
8. 调用自定义init-method
9. 调用BeanPostProcessor的postProcessAfterInitialization
10. Bean可以使用
11. 调用DisposableBean的destroy
12. 调用自定义destroy-method

**Q: AOP的实现原理？**
- 基于动态代理
- JDK动态代理：实现接口
- CGLIB代理：继承类
- 切面、切点、通知、连接点

### 4.2 Spring MVC

**Q: Spring MVC的执行流程？**
1. 用户请求 → DispatcherServlet
2. DispatcherServlet → HandlerMapping查找处理器
3. HandlerMapping返回HandlerExecutionChain
4. DispatcherServlet → HandlerAdapter调用处理器
5. 处理器返回ModelAndView
6. DispatcherServlet → ViewResolver解析视图
7. 渲染视图返回给用户

**Q: @Controller和@RestController的区别？**
- @Controller：返回视图名称
- @RestController：@Controller + @ResponseBody，返回JSON

## 五、数据库

### 5.1 SQL基础

**Q: 数据库事务的ACID特性？**
- **原子性（Atomicity）**：事务要么全部成功，要么全部失败
- **一致性（Consistency）**：数据保持一致状态
- **隔离性（Isolation）**：事务间相互隔离
- **持久性（Durability）**：事务提交后永久保存

**Q: 事务的隔离级别？**
- READ UNCOMMITTED：读未提交（脏读）
- READ COMMITTED：读已提交（不可重复读）
- REPEATABLE READ：可重复读（幻读）
- SERIALIZABLE：串行化（最高隔离级别）

**Q: 索引的类型？**
- 普通索引
- 唯一索引
- 主键索引
- 复合索引
- 全文索引

**Q: 索引的优缺点？**
- 优点：加快查询速度
- 缺点：占用空间，降低更新速度

**Q: 索引失效的情况？**
- 使用函数
- 类型转换
- 前导模糊查询（LIKE '%xxx'）
- 使用OR（部分列无索引）
- 复合索引不遵循最左前缀

### 5.2 MySQL优化

**Q: SQL优化方法？**
- 避免SELECT *
- 使用索引
- 避免在WHERE子句使用函数
- 使用LIMIT分页
- 避免子查询，使用JOIN
- 使用EXPLAIN分析执行计划

**Q: 分库分表的策略？**
- 垂直分库：按业务模块
- 水平分表：按数据量（范围、哈希、一致性哈希）

## 六、分布式

### 6.1 分布式基础

**Q: CAP理论？**
- **一致性（Consistency）**：所有节点数据一致
- **可用性（Availability）**：系统可用
- **分区容错性（Partition tolerance）**：网络分区容忍

**Q: BASE理论？**
- **基本可用（Basically Available）**
- **软状态（Soft State）**
- **最终一致性（Eventually Consistent）**

**Q: 分布式事务的解决方案？**
- 2PC（两阶段提交）
- 3PC（三阶段提交）
- TCC（Try-Confirm-Cancel）
- 消息事务（RocketMQ）
- Seata框架

### 6.2 微服务

**Q: 微服务的优缺点？**
- 优点：独立部署、技术栈灵活、团队独立
- 缺点：复杂度高、分布式问题、运维复杂

**Q: 服务注册与发现的原理？**
- 服务提供者注册到注册中心
- 服务消费者从注册中心获取服务列表
- 注册中心维护服务健康状态

## 七、算法和数据结构

**Q: 常见排序算法的时间复杂度？**
- 冒泡排序：O(n²)
- 快速排序：O(n log n)
- 归并排序：O(n log n)
- 堆排序：O(n log n)
- 计数排序：O(n+k)

**Q: 常见数据结构的时间复杂度？**
- 数组：查找O(1)，插入O(n)
- 链表：查找O(n)，插入O(1)
- 哈希表：查找O(1)，插入O(1)
- 二叉搜索树：查找O(log n)，插入O(log n)

## 八、项目经验

**Q: 如何保证接口的幂等性？**
- 唯一索引
- 分布式锁
- Token机制
- 状态机

**Q: 如何解决高并发问题？**
- 缓存（Redis）
- 消息队列削峰
- 限流（令牌桶、漏桶）
- 数据库读写分离
- CDN加速

**Q: 如何保证系统的高可用？**
- 服务冗余部署
- 负载均衡
- 熔断降级
- 监控告警
- 容灾备份

---

**面试建议：**
1. 准备项目经验，能清晰描述项目背景、技术选型、遇到的难点和解决方案
2. 准备算法题，刷LeetCode
3. 了解公司业务和技术栈
4. 准备反问问题，展现学习能力
5. 保持自信，诚实回答不会的问题

